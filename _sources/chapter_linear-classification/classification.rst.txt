
.. _sec_classification:

The Base Classification Model
=============================


You may have noticed that the implementations from scratch and the
concise implementation using framework functionality were quite similar
in the case of regression. The same is true for classification. Since
many models in this book deal with classification, it is worth adding
functionalities to support this setting specifically. This section
provides a base class for classification models to simplify future code.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import mlx.optimizers as optim
    from d2l import mlx as d2l

The ``Classifier`` Class
------------------------

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class Classifier(d2l.Module):  #@save
        """The base class of classification models."""
        def validation_step(self, batch):
            Y_hat = self(*batch[:-1])
            self.plot('loss', self.loss(Y_hat, batch[-1]), train=False)
            self.plot('acc', self.accuracy(Y_hat, batch[-1]), train=False)

By default we use a stochastic gradient descent optimizer, operating on
minibatches, just as we did in the context of linear regression.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(d2l.Module)  #@save
    def configure_optimizers(self):
        return optim.SGD(learning_rate=self.lr)

Accuracy
--------

Given the predicted probability distribution ``y_hat``, we typically
choose the class with the highest predicted probability whenever we must
output a hard prediction. Indeed, many applications require that we make
a choice. For instance, Gmail must categorize an email into “Primary”,
“Social”, “Updates”, “Forums”, or “Spam”. It might estimate
probabilities internally, but at the end of the day it has to choose one
among the classes.

When predictions are consistent with the label class ``y``, they are
correct. The classification accuracy is the fraction of all predictions
that are correct. Although it can be difficult to optimize accuracy
directly (it is not differentiable), it is often the performance measure
that we care about the most. It is often *the* relevant quantity in
benchmarks. As such, we will nearly always report it when training
classifiers.

Accuracy is computed as follows. First, if ``y_hat`` is a matrix, we
assume that the second dimension stores prediction scores for each
class. We use ``argmax`` to obtain the predicted class by the index for
the largest entry in each row. Then we compare the predicted class with
the ground truth ``y`` elementwise. Since the equality operator ``==``
is sensitive to data types, we convert ``y_hat``\ ’s data type to match
that of ``y``. The result is a tensor containing entries of 0 (false)
and 1 (true). Taking the sum yields the number of correct predictions.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(Classifier)  #@save
    def accuracy(self, Y_hat, Y, averaged=True):
        """Compute the number of correct predictions."""
        Y_hat = Y_hat.reshape((-1, Y_hat.shape[-1]))
        preds = Y_hat.argmax(axis=1).astype(Y.dtype)
        compare = (preds == Y.reshape(-1)).astype(mx.float32)
        return compare.mean() if averaged else compare

Summary
-------

Classification is a sufficiently common problem that it warrants its own
convenience functions. Of central importance in classification is the
*accuracy* of the classifier. Note that while we often care primarily
about accuracy, we train classifiers to optimize a variety of other
objectives for statistical and computational reasons. However,
regardless of which loss function was minimized during training, it is
useful to have a convenience method for assessing the accuracy of our
classifier empirically.

Exercises
---------

1. Denote by :math:`L_\textrm{v}` the validation loss, and let
   :math:`L_\textrm{v}^\textrm{q}` be its quick and dirty estimate
   computed by the loss function averaging in this section. Lastly,
   denote by :math:`l_\textrm{v}^\textrm{b}` the loss on the last
   minibatch. Express :math:`L_\textrm{v}` in terms of
   :math:`L_\textrm{v}^\textrm{q}`, :math:`l_\textrm{v}^\textrm{b}`, and
   the sample and minibatch sizes.
2. Show that the quick and dirty estimate
   :math:`L_\textrm{v}^\textrm{q}` is unbiased. That is, show that
   :math:`E[L_\textrm{v}] = E[L_\textrm{v}^\textrm{q}]`. Why would you
   still want to use :math:`L_\textrm{v}` instead?
3. Given a multiclass classification loss, denoting by :math:`l(y,y')`
   the penalty of estimating :math:`y'` when we see :math:`y` and given
   a probabilty :math:`p(y \mid x)`, formulate the rule for an optimal
   selection of :math:`y'`. Hint: express the expected loss, using
   :math:`l` and :math:`p(y \mid x)`.
