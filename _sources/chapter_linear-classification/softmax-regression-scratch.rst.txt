
.. _sec_softmax_scratch:

Softmax Regression Implementation from Scratch
==============================================


Because softmax regression is so fundamental, we believe that you ought
to know how to implement it yourself. Here, we limit ourselves to
defining the softmax-specific aspects of the model and reuse the other
components from our linear regression section, including the training
loop.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import numpy as np
    from d2l import mlx as d2l

The Softmax
-----------

Let’s begin with the most important part: the mapping from scalars to
probabilities. For a refresher, recall the operation of the sum operator
along specific dimensions in a tensor, as discussed in
:numref:`subsec_lin-alg-reduction` and
:numref:`subsec_lin-alg-non-reduction`. Given a matrix ``X`` we can
sum over all elements (by default) or only over elements in the same
axis. The ``axis`` variable lets us compute row and column sums:

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X = mx.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    X.sum(0, keepdims=True), X.sum(1, keepdims=True)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[5, 7, 9]], dtype=float32),
     array([[6],
            [15]], dtype=float32))



Computing the softmax requires three steps: (i) exponentiation of each
term; (ii) a sum over each row to compute the normalization constant for
each example; (iii) division of each row by its normalization constant,
ensuring that the result sums to 1:

.. math:: \mathrm{softmax}(\mathbf{X})_{ij} = \frac{\exp(\mathbf{X}_{ij})}{\sum_k \exp(\mathbf{X}_{ik})}.

The (logarithm of the) denominator is called the (log) *partition
function*. It was introduced in `statistical
physics <https://en.wikipedia.org/wiki/Partition_function_(statistical_mechanics)>`__
to sum over all possible states in a thermodynamic ensemble. The
implementation is straightforward:

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def softmax(X):
        X_exp = mx.exp(X)
        partition = X_exp.sum(1, keepdims=True)
        return X_exp / partition  # The broadcasting mechanism is applied here

For any input ``X``, we turn each element into a nonnegative number.
Each row sums up to 1, as is required for a probability. Caution: the
code above is *not* robust against very large or very small arguments.
While it is sufficient to illustrate what is happening, you should *not*
use this code verbatim for any serious purpose. Deep learning frameworks
have such protections built in and we will be using the built-in softmax
going forward.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X = mx.random.uniform(shape=(2, 5))
    X_prob = softmax(X)
    X_prob, X_prob.sum(1)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[0.128638, 0.202501, 0.329175, 0.141182, 0.198504],
            [0.290871, 0.164617, 0.288431, 0.139319, 0.116763]], dtype=float32),
     array([1, 1], dtype=float32))



The Model
---------

We now have everything that we need to implement the softmax regression
model. As in our linear regression example, each instance will be
represented by a fixed-length vector. Since the raw data here consists
of :math:`28 \times 28` pixel images, we flatten each image, treating
them as vectors of length 784. In later chapters, we will introduce
convolutional neural networks, which exploit the spatial structure in a
more satisfying way.

In softmax regression, the number of outputs from our network should be
equal to the number of classes. Since our dataset has 10 classes, our
network has an output dimension of 10. Consequently, our weights
constitute a :math:`784 \times 10` matrix plus a :math:`1 \times 10` row
vector for the biases. As with linear regression, we initialize the
weights ``W`` with Gaussian noise. The biases are initialized as zeros.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class SoftmaxRegressionScratch(d2l.Classifier):
        def __init__(self, num_inputs, num_outputs, lr, sigma=0.01):
            super().__init__()
            self.save_hyperparameters()
            self.W = mx.random.normal(loc=0, scale=sigma, shape=(num_inputs, num_outputs))
            self.b = mx.zeros(num_outputs)
    
        def parameters(self):
            return [self.W, self.b]

The code below defines how the network maps each input to an output.
Note that we flatten each :math:`28 \times 28` pixel image in the batch
into a vector using ``reshape`` before passing the data through our
model.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(SoftmaxRegressionScratch)
    def __call__(self, X):
        X = X.reshape((-1, self.W.shape[0]))
        return softmax(mx.matmul(X, self.W) + self.b)

The Cross-Entropy Loss
----------------------

Next we need to implement the cross-entropy loss function (introduced in
:numref:`subsec_softmax-regression-loss-func`). This may be the most
common loss function in all of deep learning. At the moment,
applications of deep learning easily cast as classification problems far
outnumber those better treated as regression problems.

Recall that cross-entropy takes the negative log-likelihood of the
predicted probability assigned to the true label. For efficiency we
avoid Python for-loops and use indexing instead. In particular, the
one-hot encoding in :math:`\mathbf{y}` allows us to select the matching
terms in :math:`\hat{\mathbf{y}}`.

To see this in action we create sample data ``y_hat`` with 2 examples of
predicted probabilities over 3 classes and their corresponding labels
``y``. The correct labels are :math:`0` and :math:`2` respectively
(i.e., the first and third class). Using ``y`` as the indices of the
probabilities in ``y_hat``, we can pick out terms efficiently.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    y = mx.array([0, 2])
    y_hat = mx.array([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]])
    y_hat[[0, 1], y]




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([0.1, 0.5], dtype=float32)



.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def cross_entropy(y_hat, y):
        return -mx.log(y_hat[list(range(len(y_hat))), y]).mean()
    
    cross_entropy(y_hat, y)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array(1.49787, dtype=float32)



.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(SoftmaxRegressionScratch)
    def loss(self, y_hat, y):
        return cross_entropy(y_hat, y)

Training
--------

We reuse the ``fit`` method defined in :numref:`sec_linear_scratch` to
train the model with 10 epochs. Note that the number of epochs
(``max_epochs``), the minibatch size (``batch_size``), and learning rate
(``lr``) are adjustable hyperparameters. That means that while these
values are not learned during our primary training loop, they still
influence the performance of our model, both vis-à-vis training and
generalization performance. In practice you will want to choose these
values based on the *validation* split of the data and then, ultimately,
to evaluate your final model on the *test* split. As discussed in
:numref:`subsec_generalization-model-selection`, we will regard the
test data of Fashion-MNIST as the validation set, thus reporting
validation loss and validation accuracy on this split.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    data = d2l.FashionMNIST(batch_size=256)
    model = SoftmaxRegressionScratch(num_inputs=784, num_outputs=10, lr=0.1)
    trainer = d2l.Trainer(max_epochs=10)
    trainer.fit(model, data)



.. figure:: output_softmax-regression-scratch_009b7c_17_0.svg


Prediction
----------

Now that training is complete, our model is ready to classify some
images.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X, y = next(iter(data.val_dataloader()))
    preds = model(X).argmax(axis=1)
    preds.shape




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (256,)



We are more interested in the images we label *incorrectly*. We
visualize them by comparing their actual labels (first line of text
output) with the predictions from the model (second line of text
output).

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    wrong = (preds.astype(y.dtype) != y)
    wrong = np.array(wrong)
    wrong = mx.array(np.where(wrong)[0])
    
    X, y, preds = X[wrong], y[wrong], preds[wrong]
    labels = [a+'\n'+b for a, b in zip(
        data.text_labels(y), data.text_labels(preds))]
    data.visualize([X, y], labels=labels)



.. figure:: output_softmax-regression-scratch_009b7c_21_0.svg


Summary
-------

By now we are starting to get some experience with solving linear
regression and classification problems. With it, we have reached what
would arguably be the state of the art of 1960–1970s of statistical
modeling. In the next section, we will show you how to leverage deep
learning frameworks to implement this model much more efficiently.

Exercises
---------

1. In this section, we directly implemented the softmax function based
   on the mathematical definition of the softmax operation. As discussed
   in :numref:`sec_softmax` this can cause numerical instabilities.

   1. Test whether ``softmax`` still works correctly if an input has a
      value of :math:`100`.
   2. Test whether ``softmax`` still works correctly if the largest of
      all inputs is smaller than :math:`-100`.
   3. Implement a fix by looking at the value relative to the largest
      entry in the argument.

2. Implement a ``cross_entropy`` function that follows the definition of
   the cross-entropy loss function :math:`\sum_i y_i \log \hat{y}_i`.

   1. Try it out in the code example of this section.
   2. Why do you think it runs more slowly?
   3. Should you use it? When would it make sense to?
   4. What do you need to be careful of? Hint: consider the domain of
      the logarithm.

3. Is it always a good idea to return the most likely label? For
   example, would you do this for medical diagnosis? How would you try
   to address this?
4. Assume that we want to use softmax regression to predict the next
   word based on some features. What are some problems that might arise
   from a large vocabulary?
5. Experiment with the hyperparameters of the code in this section. In
   particular:

   1. Plot how the validation loss changes as you change the learning
      rate.
   2. Do the validation and training loss change as you change the
      minibatch size? How large or small do you need to go before you
      see an effect?
