
.. _sec_ndarray:

Data Manipulation
=================


In order to get anything done, we need some way to store and manipulate
data. Generally, there are two important things we need to do with data:
(i) acquire them; and (ii) process them once they are inside the
computer. There is no point in acquiring data without some way to store
it, so to start, let’s get our hands dirty with :math:`n`-dimensional
arrays, which we also call *tensors*. If you already know the NumPy
scientific computing package, this will be a breeze. For all modern deep
learning frameworks, the *tensor class* (``ndarray`` in MXNet,
``Tensor`` in PyTorch and TensorFlow) resembles NumPy’s ``ndarray``,
with a few killer features added. First, the tensor class supports
automatic differentiation. Second, it leverages GPUs to accelerate
numerical computation, whereas NumPy only runs on CPUs. These properties
make neural networks both easy to code and fast to run.

Getting Started
---------------

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx
    import mlx.core as mx
    import numpy as np

A tensor represents a (possibly multidimensional) array of numerical
values. In the one-dimensional case, i.e., when only one axis is needed
for the data, a tensor is called a *vector*. With two axes, a tensor is
called a *matrix*. With :math:`k > 2` axes, we drop the specialized
names and just refer to the object as a :math:`k^\textrm{th}`-*order
tensor*.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x = mx.arange(12)
    x




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([0, 1, 2, ..., 9, 10, 11], dtype=int32)



.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x.size




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    12



We can access a tensor’s *shape* (the length along each axis) by
inspecting its ``shape`` attribute. Because we are dealing with a vector
here, the ``shape`` contains just a single element and is identical to
the size.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x.shape




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (12,)



We can change the shape of a tensor without altering its size or values,
by invoking ``reshape``. For example, we can transform our vector ``x``
whose shape is (12,) to a matrix ``X`` with shape (3, 4). This new
tensor retains all elements but reconfigures them into a matrix. Notice
that the elements of our vector are laid out one row at a time and thus
``x[3] == X[0, 3]``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X = x.reshape(3, 4)
    X




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[0, 1, 2, 3],
           [4, 5, 6, 7],
           [8, 9, 10, 11]], dtype=int32)



Note that specifying every shape component to ``reshape`` is redundant.
Because we already know our tensor’s size, we can work out one component
of the shape given the rest. For example, given a tensor of size
:math:`n` and target shape (:math:`h`, :math:`w`), we know that
:math:`w = n/h`. To automatically infer one component of the shape, we
can place a ``-1`` for the shape component that should be inferred
automatically. In our case, instead of calling ``x.reshape(3, 4)``, we
could have equivalently called ``x.reshape(-1, 4)`` or
``x.reshape(3, -1)``.

Practitioners often need to work with tensors initialized to contain all
0s or 1s. We can construct a tensor with all elements set to 0 and a
shape of (2, 3, 4) via the ``zeros`` function.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mx.zeros((2, 3, 4))




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[[0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]],
           [[0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]]], dtype=float32)



Similarly, we can create a tensor with all 1s by invoking ``ones``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mx.ones((2, 3, 4))




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]],
           [[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]]], dtype=float32)



We often wish to sample each element randomly (and independently) from a
given probability distribution. For example, the parameters of neural
networks are often initialized randomly. The following snippet creates a
tensor with elements drawn from a standard Gaussian (normal)
distribution with mean 0 and standard deviation 1.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    # Any call of a random function in mlx requires a key to be
    # specified, feeding the same key to a random function will
    # always result in the same sample being generated
    mx.random.normal(shape=(3, 4), key=mx.random.key(0))




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[1.19016, -1.09969, 0.443679, 0.59847],
           [-0.391895, 0.69262, 0.460184, -2.06858],
           [-0.214382, -0.98983, -0.67893, 0.273626]], dtype=float32)



Finally, we can construct tensors by supplying the exact values for each
element by supplying (possibly nested) Python list(s) containing
numerical literals. Here, we construct a matrix with a list of lists,
where the outermost list corresponds to axis 0, and the inner list
corresponds to axis 1.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mx.array([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[2, 1, 4, 3],
           [1, 2, 3, 4],
           [4, 3, 2, 1]], dtype=int32)



Indexing and Slicing
--------------------

As with Python lists, we can access tensor elements by indexing
(starting with 0). To access an element based on its position relative
to the end of the list, we can use negative indexing. Finally, we can
access whole ranges of indices via slicing (e.g., ``X[start:stop]``),
where the returned value includes the first index (``start``) *but not
the last* (``stop``). Finally, when only one index (or slice) is
specified for a :math:`k^\textrm{th}`-order tensor, it is applied along
axis 0. Thus, in the following code, ``[-1]`` selects the last row and
``[1:3]`` selects the second and third rows.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X[-1], X[1:3]




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([8, 9, 10, 11], dtype=int32),
     array([[4, 5, 6, 7],
            [8, 9, 10, 11]], dtype=int32))



.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X[1, 2] = 17
    X




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[0, 1, 2, 3],
           [4, 5, 17, 7],
           [8, 9, 10, 11]], dtype=int32)



If we want to assign multiple elements the same value, we apply the
indexing on the left-hand side of the assignment operation. For
instance, ``[:2, :]`` accesses the first and second rows, where ``:``
takes all the elements along axis 1 (column). While we discussed
indexing for matrices, this also works for vectors and for tensors of
more than two dimensions.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X[:2, :] = 12
    X




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[12, 12, 12, 12],
           [12, 12, 12, 12],
           [8, 9, 10, 11]], dtype=int32)



Operations
----------

Now that we know how to construct tensors and how to read from and write
to their elements, we can begin to manipulate them with various
mathematical operations. Among the most useful of these are the
*elementwise* operations. These apply a standard scalar operation to
each element of a tensor. For functions that take two tensors as inputs,
elementwise operations apply some standard binary operator on each pair
of corresponding elements. We can create an elementwise function from
any function that maps from a scalar to a scalar.

In mathematical notation, we denote such *unary* scalar operators
(taking one input) by the signature
:math:`f: \mathbb{R} \rightarrow \mathbb{R}`. This just means that the
function maps from any real number onto some other real number. Most
standard operators, including unary ones like :math:`e^x`, can be
applied elementwise.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mx.exp(x)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([1, 2.71828, 7.38906, ..., 8103.08, 22026.5, 59874.1], dtype=float32)



Likewise, we denote *binary* scalar operators, which map pairs of real
numbers to a (single) real number via the signature
:math:`f: \mathbb{R}, \mathbb{R} \rightarrow \mathbb{R}`. Given any two
vectors :math:`\mathbf{u}` and :math:`\mathbf{v}` *of the same shape*,
and a binary operator :math:`f`, we can produce a vector
:math:`\mathbf{c} = F(\mathbf{u},\mathbf{v})` by setting
:math:`c_i \gets f(u_i, v_i)` for all :math:`i`, where :math:`c_i, u_i`,
and :math:`v_i` are the :math:`i^\textrm{th}` elements of vectors
:math:`\mathbf{c}, \mathbf{u}`, and :math:`\mathbf{v}`. Here, we
produced the vector-valued
:math:`F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d` by
*lifting* the scalar function to an elementwise vector operation. The
common standard arithmetic operators for addition (``+``), subtraction
(``-``), multiplication (``*``), division (``/``), and exponentiation
(``**``) have all been *lifted* to elementwise operations for
identically-shaped tensors of arbitrary shape.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x = mx.array([1.0, 2, 4, 8])
    y = mx.array([2, 2, 2, 2])
    x + y, x - y, x * y, x / y, x ** y




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([3, 4, 6, 10], dtype=float32),
     array([-1, 0, 2, 6], dtype=float32),
     array([2, 4, 8, 16], dtype=float32),
     array([0.5, 1, 2, 4], dtype=float32),
     array([1, 4, 16, 64], dtype=float32))



In addition to elementwise computations, we can also perform linear
algebraic operations, such as dot products and matrix multiplications.
We will elaborate on these in :numref:`sec_linear-algebra`.

We can also *concatenate* multiple tensors, stacking them end-to-end to
form a larger one. We just need to provide a list of tensors and tell
the system along which axis to concatenate. The example below shows what
happens when we concatenate two matrices along rows (axis 0) instead of
columns (axis 1). We can see that the first output’s axis-0 length
(:math:`6`) is the sum of the two input tensors’ axis-0 lengths
(:math:`3 + 3`); while the second output’s axis-1 length (:math:`8`) is
the sum of the two input tensors’ axis-1 lengths (:math:`4 + 4`).

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X = mx.arange(12, dtype=mx.float32).reshape((3, 4))
    Y = mx.array([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
    mx.concatenate((X, Y), axis=0), mx.concatenate((X, Y), axis=1)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [2, 1, 4, 3],
            [1, 2, 3, 4],
            [4, 3, 2, 1]], dtype=float32),
     array([[0, 1, 2, ..., 1, 4, 3],
            [4, 5, 6, ..., 2, 3, 4],
            [8, 9, 10, ..., 3, 2, 1]], dtype=float32))



Sometimes, we want to construct a binary tensor via *logical
statements*. Take ``X == Y`` as an example. For each position ``i, j``,
if ``X[i, j]`` and ``Y[i, j]`` are equal, then the corresponding entry
in the result takes value ``1``, otherwise it takes value ``0``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X == Y




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[False, True, False, True],
           [False, False, False, False],
           [False, False, False, False]], dtype=bool)



Summing all the elements in the tensor yields a tensor with only one
element.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X.sum()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array(66, dtype=float32)



.. _subsec_broadcasting:

Broadcasting
------------


By now, you know how to perform elementwise binary operations on two
tensors of the same shape. Under certain conditions, even when shapes
differ, we can still perform elementwise binary operations by invoking
the *broadcasting mechanism*. Broadcasting works according to the
following two-step procedure: (i) expand one or both arrays by copying
elements along axes with length 1 so that after this transformation, the
two tensors have the same shape; (ii) perform an elementwise operation
on the resulting arrays.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    a = mx.arange(3).reshape((3, 1))
    b = mx.arange(2).reshape((1, 2))
    a, b




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[0],
            [1],
            [2]], dtype=int32),
     array([[0, 1]], dtype=int32))



Since ``a`` and ``b`` are :math:`3\times1` and :math:`1\times2`
matrices, respectively, their shapes do not match up. Broadcasting
produces a larger :math:`3\times2` matrix by replicating matrix ``a``
along the columns and matrix ``b`` along the rows before adding them
elementwise.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    a + b




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[0, 1],
           [1, 2],
           [2, 3]], dtype=int32)



Saving Memory
-------------

Running operations can cause new memory to be allocated to host results.
For example, if we write ``Y = X + Y``, we dereference the tensor that
``Y`` used to point to and instead point ``Y`` at the newly allocated
memory. We can demonstrate this issue with Python’s ``id()`` function,
which gives us the exact address of the referenced object in memory.
Note that after we run ``Y = Y + X``, ``id(Y)`` points to a different
location. That is because Python first evaluates ``Y + X``, allocating
new memory for the result and then points ``Y`` to this new location in
memory.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    before = id(Y)
    Y = Y + X
    id(Y) == before




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    False



This might be undesirable for two reasons. First, we do not want to run
around allocating memory unnecessarily all the time. In machine
learning, we often have hundreds of megabytes of parameters and update
all of them multiple times per second. Whenever possible, we want to
perform these updates *in place*. Second, we might point at the same
parameters from multiple variables. If we do not update in place, we
must be careful to update all of these references, lest we spring a
memory leak or inadvertently refer to stale parameters.

Fortunately, performing in-place operations is easy. We can assign the
result of an operation to a previously allocated array ``Y`` by using
slice notation: ``Y[:] = <expression>``. To illustrate this concept, we
overwrite the values of tensor ``Z``, after initializing it, using
``zeros_like``, to have the same shape as ``Y``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    Z = mx.zeros_like(Y)
    print('id(Z):', id(Z))
    Z[:] = X + Y
    print('id(Z):', id(Z))


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    id(Z): 4507520512
    id(Z): 4507520512


If the value of ``X`` is not reused in subsequent computations, we can
also use ``X[:] = X + Y`` or ``X += Y`` to reduce the memory overhead of
the operation.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    before = id(X)
    X += Y
    id(X) == before




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    True



Conversion to Other Python Objects
----------------------------------

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    A = np.array(X)
    B = mx.array(A)
    type(A), type(B)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (numpy.ndarray, mlx.core.array)



To convert a size-1 tensor to a Python scalar, we can invoke the
``item`` function or Python’s built-in functions.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    a = mx.array([3.5])
    a, a.item(), float(a.item()), int(a.item())




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([3.5], dtype=float32), 3.5, 3.5, 3)



Summary
-------

The tensor class is the main interface for storing and manipulating data
in deep learning libraries. Tensors provide a variety of functionalities
including construction routines; indexing and slicing; basic mathematics
operations; broadcasting; memory-efficient assignment; and conversion to
and from other Python objects.

Exercises
---------

1. Run the code in this section. Change the conditional statement
   ``X == Y`` to ``X < Y`` or ``X > Y``, and then see what kind of
   tensor you can get.
2. Replace the two tensors that operate by element in the broadcasting
   mechanism with other shapes, e.g., 3-dimensional tensors. Is the
   result the same as expected?
