
.. _sec_mlp-implementation:

Implementation of Multilayer Perceptrons
========================================


Multilayer perceptrons (MLPs) are not much more complex to implement
than simple linear models. The key conceptual difference is that we now
concatenate multiple layers.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import mlx.nn as nn
    from d2l import mlx as d2l

Implementation from Scratch
---------------------------

Let’s begin again by implementing such a network from scratch.

Initializing Model Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall that Fashion-MNIST contains 10 classes, and that each image
consists of a :math:`28 \times 28 = 784` grid of grayscale pixel values.
As before we will disregard the spatial structure among the pixels for
now, so we can think of this as a classification dataset with 784 input
features and 10 classes. To begin, we will implement an MLP with one
hidden layer and 256 hidden units. Both the number of layers and their
width are adjustable (they are considered hyperparameters). Typically,
we choose the layer widths to be divisible by larger powers of 2. This
is computationally efficient due to the way memory is allocated and
addressed in hardware.

Again, we will represent our parameters with several tensors. Note that
*for every layer*, we must keep track of one weight matrix and one bias
vector. As always, we allocate memory for the gradients of the loss with
respect to these parameters.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class MLPScratch(d2l.Classifier):
        def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01):
            super().__init__()
            self.save_hyperparameters()
            self.W1 = mx.random.normal(shape=(num_inputs, num_hiddens)) * sigma
            self.b1 = mx.zeros(num_hiddens)
            self.W2 = mx.random.normal(shape=(num_hiddens, num_outputs)) * sigma
            self.b2 = mx.zeros(num_outputs)

Model
~~~~~

To make sure we know how everything works, we will implement the ReLU
activation ourselves rather than invoking the built-in ``relu`` function
directly.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def relu(X):
        a = mx.zeros_like(X)
        return mx.maximum(X, a)

Since we are disregarding spatial structure, we ``reshape`` each
two-dimensional image into a flat vector of length ``num_inputs``.
Finally, we implement our model with just a few lines of code. Since we
use the framework built-in autograd this is all that it takes.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(MLPScratch)
    def __call__(self, X):
        X = X.reshape((-1, self.num_inputs))
        H = relu(mx.matmul(X, self.W1) + self.b1)
        return mx.matmul(H, self.W2) + self.b2

Training
~~~~~~~~

Fortunately, the training loop for MLPs is exactly the same as for
softmax regression. We define the model, data, and trainer, then finally
invoke the ``fit`` method on model and data.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    model = MLPScratch(num_inputs=784, num_outputs=10, num_hiddens=256, lr=0.1)
    data = d2l.FashionMNIST(batch_size=256)
    trainer = d2l.Trainer(max_epochs=10)
    trainer.fit(model, data)



.. figure:: output_mlp-implementation_161c92_9_0.svg


Concise Implementation
----------------------

As you might expect, by relying on the high-level APIs, we can implement
MLPs even more concisely.

Model
~~~~~

Compared with our concise implementation of softmax regression
implementation (:numref:`sec_softmax_concise`), the only difference is
that we add *two* fully connected layers where we previously added only
*one*. The first is the hidden layer, the second is the output layer.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class MLP(d2l.Classifier):
        def __init__(self, num_inputs, num_outputs, num_hiddens, lr):
            super().__init__()
            self.save_hyperparameters()
            self.net = nn.Sequential(nn.Sequential(lambda x: mx.array.flatten(x, start_axis=1, end_axis=-1)),
                                     nn.Linear(num_inputs, num_hiddens),
                                     nn.ReLU(),
                                     nn.Linear(num_hiddens, num_outputs))

``self.net(X)`` (``X`` is input), is now defined as a sequence of
transformations via the ``Sequential`` class. The ``Sequential`` class
abstracts the forward process enabling us to focus on the
transformations. We will further discuss how the ``Sequential`` class
works in :numref:`subsec_model-construction-sequential`.

Training
~~~~~~~~

The training loop is exactly the same as when we implemented softmax
regression. This modularity enables us to separate matters concerning
the model architecture from orthogonal considerations.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    model = MLP(num_inputs=784, num_outputs=10, num_hiddens=256, lr=0.1)
    trainer.fit(model, data)



.. figure:: output_mlp-implementation_161c92_14_0.svg


Summary
-------

Now that we have more practice in designing deep networks, the step from
a single to multiple layers of deep networks does not pose such a
significant challenge any longer. In particular, we can reuse the
training algorithm and data loader. Note, though, that implementing MLPs
from scratch is nonetheless messy: naming and keeping track of the model
parameters makes it difficult to extend models. For instance, imagine
wanting to insert another layer between layers 42 and 43. This might now
be layer 42b, unless we are willing to perform sequential renaming.
Moreover, if we implement the network from scratch, it is much more
difficult for the framework to perform meaningful performance
optimizations.

Nonetheless, you have now reached the state of the art of the late 1980s
when fully connected deep networks were the method of choice for neural
network modeling. Our next conceptual step will be to consider images.
Before we do so, we need to review a number of statistical basics and
details on how to compute models efficiently.

Exercises
---------

1. Change the number of hidden units ``num_hiddens`` and plot how its
   number affects the accuracy of the model. What is the best value of
   this hyperparameter?
2. Try adding a hidden layer to see how it affects the results.
3. Why is it a bad idea to insert a hidden layer with a single neuron?
   What could go wrong?
4. How does changing the learning rate alter your results? With all
   other parameters fixed, which learning rate gives you the best
   results? How does this relate to the number of epochs?
5. Let’s optimize over all hyperparameters jointly, i.e., learning rate,
   number of epochs, number of hidden layers, and number of hidden units
   per layer.

   1. What is the best result you can get by optimizing over all of
      them?
   2. Why it is much more challenging to deal with multiple
      hyperparameters?
   3. Describe an efficient strategy for optimizing over multiple
      parameters jointly.

6. Compare the speed of the framework and the from-scratch
   implementation for a challenging problem. How does it change with the
   complexity of the network?
7. Measure the speed of tensor–matrix multiplications for well-aligned
   and misaligned matrices. For instance, test for matrices with
   dimension 1024, 1025, 1026, 1028, and 1032.

   1. How does this change between GPUs and CPUs?
   2. Determine the memory bus width of your CPU and GPU.

8. Try out different activation functions. Which one works best?
9. Is there a difference between weight initializations of the network?
   Does it matter?
