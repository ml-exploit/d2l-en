
File I/O
========

So far we have discussed how to process data and how to build, train,
and test deep learning models. However, at some point we will hopefully
be happy enough with the learned models that we will want to save the
results for later use in various contexts (perhaps even to make
predictions in deployment). Additionally, when running a long training
process, the best practice is to periodically save intermediate results
(checkpointing) to ensure that we do not lose several days’ worth of
computation if we trip over the power cord of our server. Thus it is
time to learn how to load and store both individual weight vectors and
entire models. This section addresses both issues.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import mlx.nn as nn
    from mlx.utils import tree_flatten

Loading and Saving Tensors
--------------------------

For individual tensors, we can directly invoke the ``load`` and ``save``
functions to read and write them respectively. Both functions require
that we supply a name, and ``save`` requires as input the variable to be
saved.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x = mx.arange(4)
    mx.save('x-file', x)

We can now read the data from the stored file back into memory.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x2 = mx.load('x-file.npy')
    x2




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([0, 1, 2, 3], dtype=int32)



We can store a list of tensors and read them back into memory.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    y = mx.zeros(4)
    mx.save('x-files', mx.array((x, y)))
    x2, y2 = mx.load('x-files.npy')
    (x2, y2)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([0, 1, 2, 3], dtype=float32), array([0, 0, 0, 0], dtype=float32))



We can even write and read a dictionary that maps from strings to
tensors. This is convenient when we want to read or write all the
weights in a model.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mydict = {'x': x, 'y': y}
    mx.savez('mydict.npz', **mydict)
    mydict2 = mx.load('mydict.npz')
    mydict2




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    {'x': array([0, 1, 2, 3], dtype=int32),
     'y': array([0, 0, 0, 0], dtype=float32)}



Loading and Saving Model Parameters
-----------------------------------

Saving individual weight vectors (or other tensors) is useful, but it
gets very tedious if we want to save (and later load) an entire model.
After all, we might have hundreds of parameter groups sprinkled
throughout. For this reason the deep learning framework provides
built-in functionalities to load and save entire networks. An important
detail to note is that this saves model *parameters* and not the entire
model. For example, if we have a 3-layer MLP, we need to specify the
architecture separately. The reason for this is that the models
themselves can contain arbitrary code, hence they cannot be serialized
as naturally. Thus, in order to reinstate a model, we need to generate
the architecture in code and then load the parameters from disk. Let’s
start with our familiar MLP.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class MLP(nn.Module):
        def __init__(self):
            super().__init__()
            self.hidden = nn.Linear(20, 256)
            self.output = nn.Linear(256, 10)
            # self.layers = [self.hidden, self.output]
    
        def __call__(self, x):
            return self.output(nn.relu(self.hidden(x)))
    
    net = MLP()
    X = mx.random.normal(shape=(2, 20))
    Y = net(X)

Next, we store the parameters of the model as a file with the name
“mlp.params”.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    flat_params = tree_flatten(net.parameters())
    mx.savez("mlp-params.npz", **dict(flat_params))

To recover the model, we instantiate a clone of the original MLP model.
Instead of randomly initializing the model parameters, we read the
parameters stored in the file directly.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    clone = MLP()
    clone.load_weights('mlp-params.npz')
    clone.eval()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    MLP(
      (hidden): Linear(input_dims=20, output_dims=256, bias=True)
      (output): Linear(input_dims=256, output_dims=10, bias=True)
    )



Since both instances have the same model parameters, the computational
result of the same input ``X`` should be the same. Let’s verify this.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    Y_clone = clone(X)
    Y_clone == Y




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[True, True, True, ..., True, True, True],
           [True, True, True, ..., True, True, True]], dtype=bool)



Summary
-------

The ``save`` and ``load`` functions can be used to perform file I/O for
tensor objects. We can save and load the entire sets of parameters for a
network via a parameter dictionary. Saving the architecture has to be
done in code rather than in parameters.

Exercises
---------

1. Even if there is no need to deploy trained models to a different
   device, what are the practical benefits of storing model parameters?
2. Assume that we want to reuse only parts of a network to be
   incorporated into a network having a different architecture. How
   would you go about using, say the first two layers from a previous
   network in a new network?
3. How would you go about saving the network architecture and
   parameters? What restrictions would you impose on the architecture?
