
Parameter Management
====================

Once we have chosen an architecture and set our hyperparameters, we
proceed to the training loop, where our goal is to find parameter values
that minimize our loss function. After training, we will need these
parameters in order to make future predictions. Additionally, we will
sometimes wish to extract the parameters perhaps to reuse them in some
other context, to save our model to disk so that it may be executed in
other software, or for examination in the hope of gaining scientific
understanding.

Most of the time, we will be able to ignore the nitty-gritty details of
how parameters are declared and manipulated, relying on deep learning
frameworks to do the heavy lifting. However, when we move away from
stacked architectures with standard layers, we will sometimes need to
get into the weeds of declaring and manipulating parameters. In this
section, we cover the following:

-  Accessing parameters for debugging, diagnostics, and visualizations.
-  Sharing parameters across different model components.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import mlx.nn as nn

We start by focusing on an MLP with one hidden layer.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net = nn.Sequential(nn.Linear(4, 8),
                        nn.ReLU(),
                        nn.Linear(8, 1))
    
    X = mx.random.uniform(shape=(2, 4))
    net(X).shape




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (2, 1)



.. _subsec_param-access:

Parameter Access
----------------


Let’s start with how to access parameters from the models that you
already know.

We can inspect the parameters of the second fully connected layer as
follows.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net.layers[2].parameters()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    {'weight': array([[-0.126733, 0.33087, 0.276235, ..., -0.178032, -0.0230466, -0.285598]], dtype=float32),
     'bias': array([-0.0876096], dtype=float32)}



We can see that this fully connected layer contains two parameters,
corresponding to that layer’s weights and biases, respectively.

Targeted Parameters
~~~~~~~~~~~~~~~~~~~

Note that each parameter is represented as an instance of the parameter
class. To do anything useful with the parameters, we first need to
access the underlying numerical values. There are several ways to do
this. Some are simpler while others are more general. The following code
extracts the bias from the second neural network layer, which returns a
parameter class instance, and further accesses that parameter’s value.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    type(net.layers[2].bias), net.layers[2].bias




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (mlx.core.array, array([-0.0876096], dtype=float32))



Unlike the other frameworks, MLX does not keep a track of the gradients
over the neural network parameters, instead the parameters and the
network are decoupled. It allows the user to express their computation
as a Python function, and use the ``grad`` transformation for the same
purpose.

All Parameters at Once
~~~~~~~~~~~~~~~~~~~~~~

When we need to perform operations on all parameters, accessing them
one-by-one can grow tedious. The situation can grow especially unwieldy
when we work with more complex, e.g., nested, modules, since we would
need to recurse through the entire tree to extract each sub-module’s
parameters. Below we demonstrate accessing the parameters of all layers.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    print(*[(name, param, layers[param].shape) for name, layers in net.named_modules()[1:][::-1] for param in layers.parameters()])


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    ('layers.0', 'weight', (8, 4)) ('layers.0', 'bias', (8,)) ('layers.2', 'weight', (1, 8)) ('layers.2', 'bias', (1,))


Tied Parameters
---------------

Often, we want to share parameters across multiple layers. Let’s see how
to do this elegantly. In the following we allocate a fully connected
layer and then use its parameters specifically to set those of another
layer. Here we need to run the forward propagation ``net(X)`` before
accessing the parameters.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    # We need to give the shared layer a name so that we can refer to its
    # parameters
    shared = nn.Linear(8, 8)
    net = nn.Sequential(nn.Linear(4, 8), nn.ReLU(),
                        shared, nn.ReLU(),
                        shared, nn.ReLU(),
                        nn.Linear(8, 1))
    
    net(X)
    # Check whether the parameters are the same
    print(net.layers[2].weight[0] == net.layers[4].weight[0])
    net.layers[2].weight[0, 0] = 100
    # Make sure that they are actually the same object rather than just having the
    # same value
    print(net.layers[2].weight[0]  == net.layers[4].weight[0])


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([True, True, True, ..., True, True, True], dtype=bool)
    array([True, True, True, ..., True, True, True], dtype=bool)


This example shows that the parameters of the second and third layer are
tied. They are not just equal, they are represented by the same exact
tensor. Thus, if we change one of the parameters, the other one changes,
too.

Summary
-------

We have several ways of accessing and tying model parameters.

Exercises
---------

1. Use the ``NestMLP`` model defined in
   :numref:`sec_model_construction` and access the parameters of the
   various layers.
2. Construct an MLP containing a shared parameter layer and train it.
   During the training process, observe the model parameters and
   gradients of each layer.
3. Why is sharing parameters a good idea?
