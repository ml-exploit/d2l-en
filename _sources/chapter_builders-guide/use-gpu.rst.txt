
.. _sec_use_gpu:

GPUs
====


In :numref:`tab_intro_decade`, we illustrated the rapid growth of
computation over the past two decades. In a nutshell, GPU performance
has increased by a factor of 1000 every decade since 2000. This offers
great opportunities but it also suggests that there was significant
demand for such performance.

In this section, we begin to discuss how to harness this computational
performance for your research. First by using a single GPU and at a
later point, how to use multiple GPUs and multiple servers (with
multiple GPUs).

Specifically, we will discuss how to use a single NVIDIA GPU for
calculations. First, make sure you have at least one NVIDIA GPU
installed. Then, download the `NVIDIA driver and
CUDA <https://developer.nvidia.com/cuda-downloads>`__ and follow the
prompts to set the appropriate path. Once these preparations are
complete, the ``nvidia-smi`` command can be used to view the graphics
card information.

To run the programs in this section, you need at least two GPUs. Note
that this might be extravagant for most desktop computers but it is
easily available in the cloud, e.g., by using the AWS EC2 multi-GPU
instances. Almost all other sections do *not* require multiple GPUs, but
here we simply wish to illustrate data flow between different devices.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import mlx.core as mx
    import mlx.nn as nn
    import torch
    from d2l import mlx as d2l

Computing Devices
-----------------

We can specify devices, such as CPUs and GPUs, for storage and
calculation. By default, tensors are created in the main memory and then
the CPU is used for calculations.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def cpu():  #@save
        """Get the CPU device."""
        mx.set_default_device(mx.cpu)
        return mx.default_device()
    
    def gpu(i=0):  #@save
        """Get a GPU device."""
        mx.set_default_device(mx.gpu)
        return mx.default_device()
    
    cpu(), gpu(), gpu(1)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (Device(cpu, 0), Device(gpu, 0), Device(gpu, 0))



We can query the number of available GPUs.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def num_gpus():  #@save
        """Get the number of available GPUs."""
        return 1
    
    num_gpus()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    1



Now we define two convenient functions that allow us to run code even if
the requested GPUs do not exist.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def try_gpu(i=0):  #@save
        """Return gpu(i) if exists, otherwise return cpu()."""
        return gpu(0)
    
    def try_all_gpus():  #@save
        """Return all available GPUs, or [cpu(),] if no GPU exists."""
        return [gpu(0)]
    
    try_gpu(), try_gpu(10), try_all_gpus()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (Device(gpu, 0), Device(gpu, 0), [Device(gpu, 0)])



Tensors and GPUs
----------------

By default, tensors are created on the GPU/TPU if they are available,
else CPU is used if not available. We can query the device where the
tensor is located.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x = mx.array([1, 2, 3])
    mx.default_device()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    Device(gpu, 0)



It is important to note that whenever we want to operate on multiple
terms, they need to be on the same device. For instance, if we sum two
tensors, we need to make sure that both arguments live on the same
device—otherwise the framework would not know where to store the result
or even how to decide where to perform the computation.

Storage on the GPU
~~~~~~~~~~~~~~~~~~

There are several ways to store a tensor on the GPU. For example, we can
specify a storage device when creating a tensor. Next, we create the
tensor variable ``X`` on the first ``gpu``. The tensor created on a GPU
only consumes the memory of this GPU. We can use the ``nvidia-smi``
command to view GPU memory usage. In general, we need to make sure that
we do not create data that exceeds the GPU memory limit.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    X = mx.ones(shape=(2, 3))
    X, mx.default_device()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[1, 1, 1],
            [1, 1, 1]], dtype=float32),
     Device(gpu, 0))



Assuming that you have at least two GPUs, the following code will create
a random tensor, ``Y``, on the second GPU.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    Y = mx.random.uniform(shape=(2, 3))
    Y, mx.default_device()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[0.496423, 0.112784, 0.439],
            [0.530845, 0.19399, 0.156726]], dtype=float32),
     Device(gpu, 0))



Copying
~~~~~~~

There is no copying in mlx

If we want to compute ``X + Y``, we need to decide where to perform this
operation. For instance, as shown in :numref:`fig_copyto`, we can
transfer ``X`` to the second GPU and perform the operation there. *Do
not* simply add ``X`` and ``Y``, since this will result in an exception.
The runtime engine would not know what to do: it cannot find data on the
same device and it fails. Since ``Y`` lives on the second GPU, we need
to move ``X`` there before we can add the two.

.. _fig_copyto:

.. figure:: ../img/copyto.svg

   Copy data to perform an operation on the same device.


Now that the data (both ``Z`` and ``Y``) are on the same GPU), we can
add them up.

Side Notes
~~~~~~~~~~

People use GPUs to do machine learning because they expect them to be
fast. But transferring variables between devices is slow: much slower
than computation. So we want you to be 100% certain that you want to do
something slow before we let you do it. If the deep learning framework
just did the copy automatically without crashing then you might not
realize that you had written some slow code.

Transferring data is not only slow, it also makes parallelization a lot
more difficult, since we have to wait for data to be sent (or rather to
be received) before we can proceed with more operations. This is why
copy operations should be taken with great care. As a rule of thumb,
many small operations are much worse than one big operation. Moreover,
several operations at a time are much better than many single operations
interspersed in the code unless you know what you are doing. This is the
case since such operations can block if one device has to wait for the
other before it can do something else. It is a bit like ordering your
coffee in a queue rather than pre-ordering it by phone and finding out
that it is ready when you are.

Last, when we print tensors or convert tensors to the NumPy format, if
the data is not in the main memory, the framework will copy it to the
main memory first, resulting in additional transmission overhead. Even
worse, it is now subject to the dreaded global interpreter lock that
makes everything wait for Python to complete.

Neural Networks and GPUs
------------------------

Similarly, a neural network model can specify devices. The following
code puts the model parameters on the GPU.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net = nn.Sequential(nn.Linear(3, 1))
    gpu()
    net = net

We will see many more examples of how to run models on GPUs in the
following chapters, simply because the models will become somewhat more
computationally intensive.

For example, when the input is a tensor on the GPU, the model will
calculate the result on the same GPU.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net(X)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[0.706855],
           [0.706855]], dtype=float32)



Let’s confirm that the model parameters are stored on the same GPU.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net.layers[0].weight, mx.default_device()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (array([[-0.0196834, -0.295838, 0.549062]], dtype=float32), Device(gpu, 0))



Let the trainer support GPU.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    @d2l.add_to_class(d2l.Trainer)  #@save
    def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0):
        self.save_hyperparameters()
        self.gpus = [d2l.gpu(i) for i in range(min(num_gpus, d2l.num_gpus()))]
    
    @d2l.add_to_class(d2l.Trainer)  #@save
    def prepare_batch(self, batch):
        if self.gpus:
            gpu()
            batch = [a for a in batch]
        return batch
    
    @d2l.add_to_class(d2l.Trainer)  #@save
    def prepare_model(self, model):
        model.trainer = self
        model.board.xlim = [0, self.max_epochs]
        if self.gpus:
            gpu()
        self.model = model

In short, as long as all data and parameters are on the same device, we
can learn models efficiently. In the following chapters we will see
several such examples.

Summary
-------

We can specify devices for storage and calculation, such as the CPU or
GPU. By default, data is created in the main memory and then uses the
CPU for calculations. The deep learning framework requires all input
data for calculation to be on the same device, be it CPU or the same
GPU. You can lose significant performance by moving data without care. A
typical mistake is as follows: computing the loss for every minibatch on
the GPU and reporting it back to the user on the command line (or
logging it in a NumPy ``ndarray``) will trigger a global interpreter
lock which stalls all GPUs. It is much better to allocate memory for
logging inside the GPU and only move larger logs.

Exercises
---------

1. Try a larger computation task, such as the multiplication of large
   matrices, and see the difference in speed between the CPU and GPU.
   What about a task with a small number of calculations?
2. How should we read and write model parameters on the GPU?
3. Measure the time it takes to compute 1000 matrix–matrix
   multiplications of :math:`100 \times 100` matrices and log the
   Frobenius norm of the output matrix one result at a time. Compare it
   with keeping a log on the GPU and transferring only the final result.
4. Measure how much time it takes to perform two matrix–matrix
   multiplications on two GPUs at the same time. Compare it with
   computing in in sequence on one GPU. Hint: you should see almost
   linear scaling.
