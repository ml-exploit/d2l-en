
.. _sec_minibatch_sgd:

Minibatch Stochastic Gradient Descent
=====================================


So far we encountered two extremes in the approach to gradient-based
learning: :numref:`sec_gd` uses the full dataset to compute gradients
and to update parameters, one pass at a time. Conversely
:numref:`sec_sgd` processes one training example at a time to make
progress. Either of them has its own drawbacks. Gradient descent is not
particularly *data efficient* whenever data is very similar. Stochastic
gradient descent is not particularly *computationally efficient* since
CPUs and GPUs cannot exploit the full power of vectorization. This
suggests that there might be something in between, and in fact, that is
what we have been using so far in the examples we discussed.

Vectorization and Caches
------------------------

At the heart of the decision to use minibatches is computational
efficiency. This is most easily understood when considering
parallelization to multiple GPUs and multiple servers. In this case we
need to send at least one image to each GPU. With 8 GPUs per server and
16 servers we already arrive at a minibatch size no smaller than 128.

Things are a bit more subtle when it comes to single GPUs or even CPUs.
These devices have multiple types of memory, often multiple types of
computational units and different bandwidth constraints between them.
For instance, a CPU has a small number of registers and then the L1, L2,
and in some cases even L3 cache (which is shared among different
processor cores). These caches are of increasing size and latency (and
at the same time they are of decreasing bandwidth). Suffice to say, the
processor is capable of performing many more operations than what the
main memory interface is able to provide.

First, a 2GHz CPU with 16 cores and AVX-512 vectorization can process up
to :math:`2 \cdot 10^9 \cdot 16 \cdot 32 = 10^{12}` bytes per second.
The capability of GPUs easily exceeds this number by a factor of 100. On
the other hand, a midrange server processor might not have much more
than 100 GB/s bandwidth, i.e., less than one tenth of what would be
required to keep the processor fed. To make matters worse, not all
memory access is created equal: memory interfaces are typically 64 bit
wide or wider (e.g., on GPUs up to 384 bit), hence reading a single byte
incurs the cost of a much wider access.

Second, there is significant overhead for the first access whereas
sequential access is relatively cheap (this is often called a burst
read). There are many more things to keep in mind, such as caching when
we have multiple sockets, chiplets, and other structures. See this
`Wikipedia article <https://en.wikipedia.org/wiki/Cache_hierarchy>`__
for a more in-depth discussion.

The way to alleviate these constraints is to use a hierarchy of CPU
caches that are actually fast enough to supply the processor with data.
This is *the* driving force behind batching in deep learning. To keep
matters simple, consider matrix-matrix multiplication, say
:math:`\mathbf{A} = \mathbf{B}\mathbf{C}`. We have a number of options
for calculating :math:`\mathbf{A}`. For instance, we could try the
following:

1. We could compute
   :math:`\mathbf{A}_{ij} = \mathbf{B}_{i,:} \mathbf{C}_{:,j}`, i.e., we
   could compute it elementwise by means of dot products.
2. We could compute
   :math:`\mathbf{A}_{:,j} = \mathbf{B} \mathbf{C}_{:,j}`, i.e., we
   could compute it one column at a time. Likewise we could compute
   :math:`\mathbf{A}` one row :math:`\mathbf{A}_{i,:}` at a time.
3. We could simply compute :math:`\mathbf{A} = \mathbf{B} \mathbf{C}`.
4. We could break :math:`\mathbf{B}` and :math:`\mathbf{C}` into smaller
   block matrices and compute :math:`\mathbf{A}` one block at a time.

If we follow the first option, we will need to copy one row and one
column vector into the CPU each time we want to compute an element
:math:`\mathbf{A}_{ij}`. Even worse, due to the fact that matrix
elements are aligned sequentially we are thus required to access many
disjoint locations for one of the two vectors as we read them from
memory. The second option is much more favorable. In it, we are able to
keep the column vector :math:`\mathbf{C}_{:,j}` in the CPU cache while
we keep on traversing through :math:`\mathbf{B}`. This halves the memory
bandwidth requirement with correspondingly faster access. Of course,
option 3 is most desirable. Unfortunately, most matrices might not
entirely fit into cache (this is what we are discussing after all).
However, option 4 offers a practically useful alternative: we can move
blocks of the matrix into cache and multiply them locally. Optimized
libraries take care of this for us. Let’s have a look at how efficient
these operations are in practice.

Beyond computational efficiency, the overhead introduced by Python and
by the deep learning framework itself is considerable. Recall that each
time we execute a command the Python interpreter sends a command to the
MXNet engine which needs to insert it into the computational graph and
deal with it during scheduling. Such overhead can be quite detrimental.
In short, it is highly advisable to use vectorization (and matrices)
whenever possible.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    %matplotlib inline
    import time
    import mlx.core as mx
    import mlx.optimizers as optim
    import numpy as np
    from mlx import nn
    from d2l import mlx as d2l
    
    A = mx.zeros([256, 256])
    B = mx.random.normal([256, 256])
    C = mx.random.normal([256, 256])

Since we will benchmark the running time frequently in the rest of the
book, let’s define a timer.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    class Timer:  #@save
        """Record multiple running times."""
        def __init__(self):
            self.times = []
            self.start()
    
        def start(self):
            """Start the timer."""
            self.tik = time.time()
    
        def stop(self):
            """Stop the timer and record the time in a list."""
            self.times.append(time.time() - self.tik)
            return self.times[-1]
    
        def avg(self):
            """Return the average time."""
            return sum(self.times) / len(self.times)
    
        def sum(self):
            """Return the sum of time."""
            return sum(self.times)
    
        def cumsum(self):
            """Return the accumulated time."""
            return np.array(self.times).cumsum().tolist()
    
    timer = Timer()

Element-wise assignment simply iterates over all rows and columns of
:math:`\mathbf{B}` and :math:`\mathbf{C}` respectively to assign the
value to :math:`\mathbf{A}`.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    # Compute A = BC one element at a time
    timer.start()
    for i in range(256):
        for j in range(256):
            A[i, j] = mx.tensordot(B[i, :], C[:, j], axes=1)
    timer.stop()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    0.3288869857788086



A faster strategy is to perform column-wise assignment.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    # Compute A = BC one column at a time
    timer.start()
    for j in range(256):
        A[:, j] = mx.matmul(B, C[:, j])
    timer.stop()




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    0.0008697509765625



Last, the most effective manner is to perform the entire operation in
one block. Note that multiplying any two matrices
:math:`\mathbf{B} \in \mathbb{R}^{m \times n}` and
:math:`\mathbf{C} \in \mathbb{R}^{n \times p}` takes approximately
:math:`2mnp` floating point operations, when scalar multiplication and
addition are counted as separate operations (fused in practice). Thus,
multiplying two :math:`256 \times 256` matrices takes :math:`0.03`
billion floating point operations. Let’s see what the respective speed
of the operations is.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    # Compute A = BC in one go
    timer.start()
    A = mx.matmul(B, C)
    timer.stop()
    
    gigaflops = [2/i for i in timer.times]
    print(f'performance in Gigaflops: element {gigaflops[0]:.3f}, '
          f'column {gigaflops[1]:.3f}, full {gigaflops[2]:.3f}')


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    performance in Gigaflops: element 6.081, column 2299.509, full 7.543


.. _sec_minibatches:

Minibatches
-----------


In the past we took it for granted that we would read *minibatches* of
data rather than single observations to update parameters. We now give a
brief justification for it. Processing single observations requires us
to perform many single matrix-vector (or even vector-vector)
multiplications, which is quite expensive and which incurs a significant
overhead on behalf of the underlying deep learning framework. This
applies both to evaluating a network when applied to data (often
referred to as inference) and when computing gradients to update
parameters. That is, this applies whenever we perform
:math:`\mathbf{w} \leftarrow \mathbf{w} - \eta_t \mathbf{g}_t` where

.. math:: \mathbf{g}_t = \partial_{\mathbf{w}} f(\mathbf{x}_{t}, \mathbf{w})

We can increase the *computational* efficiency of this operation by
applying it to a minibatch of observations at a time. That is, we
replace the gradient :math:`\mathbf{g}_t` over a single observation by
one over a small batch

.. math:: \mathbf{g}_t = \partial_{\mathbf{w}} \frac{1}{|\mathcal{B}_t|} \sum_{i \in \mathcal{B}_t} f(\mathbf{x}_{i}, \mathbf{w})

Let’s see what this does to the statistical properties of
:math:`\mathbf{g}_t`: since both :math:`\mathbf{x}_t` and also all
elements of the minibatch :math:`\mathcal{B}_t` are drawn uniformly at
random from the training set, the expectation of the gradient remains
unchanged. The variance, on the other hand, is reduced significantly.
Since the minibatch gradient is composed of
:math:`b \stackrel{\textrm{def}}{=} |\mathcal{B}_t|` independent
gradients which are being averaged, its standard deviation is reduced by
a factor of :math:`b^{-\frac{1}{2}}`. This, by itself, is a good thing,
since it means that the updates are more reliably aligned with the full
gradient.

Naively this would indicate that choosing a large minibatch
:math:`\mathcal{B}_t` would be universally desirable. Alas, after some
point, the additional reduction in standard deviation is minimal when
compared to the linear increase in computational cost. In practice we
pick a minibatch that is large enough to offer good computational
efficiency while still fitting into the memory of a GPU. To illustrate
the savings let’s have a look at some code. In it we perform the same
matrix-matrix multiplication, but this time broken up into “minibatches”
of 64 columns at a time.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    timer.start()
    for j in range(0, 256, 64):
        A[:, j:j+64] = mx.matmul(B, C[:, j:j+64])
    timer.stop()
    print(f'performance in Gigaflops: block {2 / timer.times[3]:.3f}')


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    performance in Gigaflops: block 31300.776


As we can see, the computation on the minibatch is essentially as
efficient as on the full matrix. A word of caution is in order. In
:numref:`sec_batch_norm` we used a type of regularization that was
heavily dependent on the amount of variance in a minibatch. As we
increase the latter, the variance decreases and with it the benefit of
the noise-injection due to batch normalization. See e.g.,
:cite:t:`Ioffe.2017` for details on how to rescale and compute the
appropriate terms.

Reading the Dataset
-------------------

Let’s have a look at how minibatches are efficiently generated from
data. In the following we use a dataset developed by NASA to test the
wing `noise from different
aircraft <https://archive.ics.uci.edu/dataset/291/airfoil+self+noise>`__
to compare these optimization algorithms. For convenience we only use
the first :math:`1,500` examples. The data is whitened for
preprocessing, i.e., we remove the mean and rescale the variance to
:math:`1` per coordinate.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    d2l.DATA_HUB['airfoil'] = (d2l.DATA_URL + 'airfoil_self_noise.dat',
                               '76e5be1548fd8222e5074cf0faae75edff8cf93f')
    
    #@save
    def get_data_ch11(batch_size=10, n=1500):
        data = np.genfromtxt(d2l.download('airfoil'),
                             dtype=np.float32, delimiter='\t')
        data = mx.array((data - data.mean(axis=0)) / data.std(axis=0))
    
    
    
        data_iter = d2l.load_array((data[:n, :-1], data[:n, -1]),
                                   batch_size, is_train=True)
        return data_iter, data.shape[1]-1

Implementation from Scratch
---------------------------

Recall the minibatch stochastic gradient descent implementation from
:numref:`sec_linear_scratch`. In the following we provide a slightly
more general implementation. For convenience it has the same call
signature as the other optimization algorithms introduced later in this
chapter. Specifically, we add the status input ``states`` and place the
hyperparameter in dictionary ``hyperparams``. In addition, we will
average the loss of each minibatch example in the training function, so
the gradient in the optimization algorithm does not need to be divided
by the batch size.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def sgd(params, states, hyperparams, grads):
        lr = hyperparams["learning_rate"]
        for i in range(len(params)):
            params[i] -= lr * grads[i]

Next, we implement a generic training function to facilitate the use of
the other optimization algorithms introduced later in this chapter. It
initializes a linear regression model and can be used to train the model
with minibatch stochastic gradient descent and other algorithms
introduced subsequently.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def train_ch11(trainer_fn, states, hyperparams, data_iter, valid_iter,
                   feature_dim, num_epochs=2):
        # Initialization
        w = mx.random.normal(loc=0.0, scale=0.01, shape=[feature_dim, 1])
        b = mx.zeros((1))
        params = [w, b]
        num_batches = d2l.get_num_batch(data_iter)
        net = lambda X, params: d2l.linreg(X, params)
        def loss_fn(params, X, y):
            return mx.mean(d2l.squared_loss(net(X, params), y))
        loss_and_grad_fn = mx.value_and_grad(loss_fn)
        # Train
        animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                                xlim=[0, num_epochs], ylim=[0.22, 0.40])
        n, timer = 0, d2l.Timer()
        for epoch in range(num_epochs):
            for samples in data_iter:
                X, y = mx.array(samples["X"]), mx.array(samples["y"])
                loss, grads = loss_and_grad_fn(params, X, y)
                trainer_fn(params, states, hyperparams, grads)
                mx.eval(params)
                n += X.shape[0]
    
                if n % 200 == 0:
                    timer.stop()
                    animator.add(n/X.shape[0]/num_batches,
                                 (d2l.evaluate_loss(net, valid_iter, d2l.squared_loss, params),))
                    timer.start()
            data_iter.reset()
        print(f'loss: {animator.Y[0][-1]:.3f}, {timer.avg():.3f} sec/epoch')
        return timer.cumsum(), animator.Y[0]

Let’s see how optimization proceeds for batch gradient descent. This can
be achieved by setting the minibatch size to 1500 (i.e., to the total
number of examples). As a result the model parameters are updated only
once per epoch. There is little progress. In fact, after 6 steps
progress stalls.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def train_sgd(lr, batch_size, num_epochs=2):
        data_iter, feature_dim = get_data_ch11(batch_size)
        valid_iter, _ = get_data_ch11(batch_size)
        num_batches = d2l.get_num_batch(data_iter)
        print(f'num_batches: {num_batches}, feature_dim: {feature_dim}')
        return train_ch11(
            sgd, None, {'learning_rate': lr}, data_iter, valid_iter, feature_dim, num_epochs)
    
    gd_res = train_sgd(1, 1500, 10)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss: 0.246, 0.006 sec/epoch



.. figure:: output_minibatch-sgd_356976_19_1.svg


When the batch size equals 1, we use stochastic gradient descent for
optimization. For simplicity of implementation we picked a constant
(albeit small) learning rate. In stochastic gradient descent, the model
parameters are updated whenever an example is processed. In our case
this amounts to 1500 updates per epoch. As we can see, the decline in
the value of the objective function slows down after one epoch. Although
both the procedures processed 1500 examples within one epoch, stochastic
gradient descent consumes more time than gradient descent in our
experiment. This is because stochastic gradient descent updated the
parameters more frequently and since it is less efficient to process
single observations one at a time.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    sgd_res = train_sgd(0.005, 1)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss: 0.243, 0.069 sec/epoch



.. figure:: output_minibatch-sgd_356976_21_1.svg


Finally, when the batch size equals 100, we use minibatch stochastic
gradient descent for optimization. The time required per epoch is
shorter than the time needed for stochastic gradient descent and the
time for batch gradient descent.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mini1_res = train_sgd(.4, 100)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss: 0.243, 0.001 sec/epoch



.. figure:: output_minibatch-sgd_356976_23_1.svg


Reducing the batch size to 10, the time for each epoch increases because
the workload for each batch is less efficient to execute.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    mini2_res = train_sgd(.05, 10)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss: 0.249, 0.009 sec/epoch



.. figure:: output_minibatch-sgd_356976_25_1.svg


Now we can compare the time vs. loss for the previous four experiments.
As can be seen, although stochastic gradient descent converges faster
than GD in terms of number of examples processed, it uses more time to
reach the same loss than GD because computing the gradient example by
example is not as efficient. Minibatch stochastic gradient descent is
able to trade-off convergence speed and computation efficiency. A
minibatch size of 10 is more efficient than stochastic gradient descent;
a minibatch size of 100 even outperforms GD in terms of runtime.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    d2l.set_figsize([6, 3])
    d2l.plot(*list(map(list, zip(gd_res, sgd_res, mini1_res, mini2_res))),
             'time (sec)', 'loss', xlim=[1e-2, 10],
             legend=['gd', 'sgd', 'batch size=100', 'batch size=10'])
    d2l.plt.gca().set_xscale('log')



.. figure:: output_minibatch-sgd_356976_27_0.svg


Concise Implementation
----------------------

In Gluon, we can use the ``Trainer`` class to call optimization
algorithms. This is used to implement a generic training function. We
will use this throughout the current chapter.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def train_concise_ch11(trainer_fn, hyperparams, data_iter, valid_iter, num_epochs=4):
        # Initialization
        net = nn.Sequential(nn.Linear(5, 1))
    
        params = net.parameters()
        weight_fn = nn.init.normal(mean=0.0, std=0.01)
        bias_fn = nn.init.constant(0.0)
        net.layers[0].weight = weight_fn(params["layers"][0]["weight"])
        net.layers[0].bias = bias_fn(params["layers"][0]["bias"])
        num_batches = d2l.get_num_batch(data_iter)
        optimizer = trainer_fn(**hyperparams)
        def loss_fn(net, X, y):
            y_hat = net(X)
            y = y.reshape(y_hat.shape)
            return nn.losses.mse_loss(y_hat, y, reduction='mean')
        animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                                xlim=[0, num_epochs], ylim=[0.22, 0.40])
        n, timer = 0, d2l.Timer()
        for _ in range(num_epochs):
            for samples in data_iter:
                X, y = mx.array(samples["X"]), mx.array(samples["y"])
                loss_and_grad_fn = nn.value_and_grad(net, loss_fn)
                loss, grads = loss_and_grad_fn(net, X, y)
                optimizer.update(net, grads)
                mx.eval(net.state)
    
                n += X.shape[0]
                if n % 200 == 0:
                    timer.stop()
                    # `MeanSquaredError` computes squared error without the 1/2
                    # factor
                    animator.add(n/X.shape[0]/num_batches,
                                 (d2l.evaluate_loss(net, valid_iter, nn.losses.mse_loss, None) / 2,))
                    timer.start()
            data_iter.reset()
        print(f'loss: {animator.Y[0][-1]:.3f}, {timer.avg():.3f} sec/epoch')

Using Gluon to repeat the last experiment shows identical behavior.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    data_iter, _ = get_data_ch11(10)
    valid_iter, _ = get_data_ch11(10)
    trainer = optim.SGD
    train_concise_ch11(trainer, {'learning_rate': 0.01}, data_iter, valid_iter)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss: 0.243, 0.008 sec/epoch



.. figure:: output_minibatch-sgd_356976_31_1.svg


Summary
-------

-  Vectorization makes code more efficient due to reduced overhead
   arising from the deep learning framework and due to better memory
   locality and caching on CPUs and GPUs.
-  There is a trade-off between statistical efficiency arising from
   stochastic gradient descent and computational efficiency arising from
   processing large batches of data at a time.
-  Minibatch stochastic gradient descent offers the best of both worlds:
   computational and statistical efficiency.
-  In minibatch stochastic gradient descent we process batches of data
   obtained by a random permutation of the training data (i.e., each
   observation is processed only once per epoch, albeit in random
   order).
-  It is advisable to decay the learning rates during training.
-  In general, minibatch stochastic gradient descent is faster than
   stochastic gradient descent and gradient descent for convergence to a
   smaller risk, when measured in terms of clock time.

Exercises
---------

1. Modify the batch size and learning rate and observe the rate of
   decline for the value of the objective function and the time consumed
   in each epoch.
2. Read the MXNet documentation and use the ``Trainer`` class
   ``set_learning_rate`` function to reduce the learning rate of the
   minibatch stochastic gradient descent to 1/10 of its previous value
   after each epoch.
3. Compare minibatch stochastic gradient descent with a variant that
   actually *samples with replacement* from the training set. What
   happens?
4. An evil genie replicates your dataset without telling you (i.e., each
   observation occurs twice and your dataset grows to twice its original
   size, but nobody told you). How does the behavior of stochastic
   gradient descent, minibatch stochastic gradient descent and that of
   gradient descent change?
