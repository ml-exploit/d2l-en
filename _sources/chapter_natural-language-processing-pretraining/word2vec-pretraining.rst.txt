
.. _sec_word2vec_pretraining:

Pretraining word2vec
====================


We go on to implement the skip-gram model defined in
:numref:`sec_word2vec`. Then we will pretrain word2vec using negative
sampling on the PTB dataset. First of all, let’s obtain the data
iterator and the vocabulary for this dataset by calling the
``d2l.load_data_ptb`` function, which was described in
:numref:`sec_word2vec_data`

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import math
    import mlx.core as mx
    import mlx.optimizers as optim
    from mlx import nn
    from d2l import mlx as d2l
    
    batch_size, max_window_size, num_noise_words = 512, 5, 5
    data_iter, num_batches, vocab = d2l.load_data_ptb(batch_size, max_window_size,
                                         num_noise_words)

The Skip-Gram Model
-------------------

We implement the skip-gram model by using embedding layers and batch
matrix multiplications. First, let’s review how embedding layers work.

Embedding Layer
~~~~~~~~~~~~~~~

As described in :numref:`sec_seq2seq`, an embedding layer maps a
token’s index to its feature vector. The weight of this layer is a
matrix whose number of rows equals to the dictionary size
(``input_dim``) and number of columns equals to the vector dimension for
each token (``output_dim``). After a word embedding model is trained,
this weight is what we need.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    embed = nn.Embedding(num_embeddings=20, dims=4)
    print(f'Parameter embedding_weight ({embed.weight.shape}, '
          f'dtype={embed.weight.dtype})')


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    Parameter embedding_weight ((20, 4), dtype=mlx.core.float32)


The input of an embedding layer is the index of a token (word). For any
token index :math:`i`, its vector representation can be obtained from
the :math:`i^\textrm{th}` row of the weight matrix in the embedding
layer. Since the vector dimension (``output_dim``) was set to 4, the
embedding layer returns vectors with shape (2, 3, 4) for a minibatch of
token indices with shape (2, 3).

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    x = mx.array([[1, 2, 3], [4, 5, 6]])
    embed(x)




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([[[-0.0621401, 0.515306, -0.149054, -0.195119],
            [-0.541183, 0.41583, -0.615067, -0.501261],
            [0.198281, 0.296762, -0.784606, -0.0265169]],
           [[0.788474, -0.438938, -0.257211, 0.52742],
            [-0.314468, -0.289532, 0.568899, 0.681304],
            [0.646986, 0.374493, 0.0788575, -0.0965961]]], dtype=float32)



Defining the Forward Propagation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the forward propagation, the input of the skip-gram model includes
the center word indices ``center`` of shape (batch size, 1) and the
concatenated context and noise word indices ``contexts_and_negatives``
of shape (batch size, ``max_len``), where ``max_len`` is defined in
:numref:`subsec_word2vec-minibatch-loading`. These two variables are
first transformed from the token indices into vectors via the embedding
layer, then their batch matrix multiplication (described in
:numref:`subsec_batch_dot`) returns an output of shape (batch size, 1,
``max_len``). Each element in the output is the dot product of a center
word vector and a context or noise word vector.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def skip_gram(center, contexts_and_negatives, embed_v, embed_u):
        v = embed_v(center)
        u = embed_u(contexts_and_negatives)
        pred = mx.einsum('bij,bkj->bik', v, u)
        return pred

Let’s print the output shape of this ``skip_gram`` function for some
example inputs.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    skip_gram(mx.ones((2, 1), dtype=mx.int32),
              mx.ones((2, 4), dtype=mx.int32), embed, embed).shape




.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    (2, 1, 4)



Training
--------

Before training the skip-gram model with negative sampling, let’s first
define its loss function.

Binary Cross-Entropy Loss
~~~~~~~~~~~~~~~~~~~~~~~~~

According to the definition of the loss function for negative sampling
in :numref:`subsec_negative-sampling`, we will use the binary
cross-entropy loss.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    loss = nn.losses.binary_cross_entropy

Recall our descriptions of the mask variable and the label variable in
:numref:`subsec_word2vec-minibatch-loading`. The following calculates
the binary cross-entropy loss for the given variables.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    pred = mx.array([[1.1, -2.2, 3.3, -4.4]] * 2)
    label = mx.array([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])
    mask = mx.array([[1, 1, 1, 1], [1, 1, 0, 0]])
    print(loss(inputs=pred, targets=label, weights=mask, with_logits=True, reduction='none').sum(axis=1) / mask.sum(axis=1))


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    array([0.93521, 1.84621], dtype=float32)


Below shows how the above results are calculated (in a less efficient
way) using the sigmoid activation function in the binary cross-entropy
loss. We can consider the two outputs as two normalized losses that are
averaged over non-masked predictions.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def sigmd(x):
        return -math.log(1 / (1 + math.exp(-x)))
    
    print(f'{(sigmd(1.1) + sigmd(2.2) + sigmd(-3.3) + sigmd(4.4)) / 4:.4f}')
    print(f'{(sigmd(-1.1) + sigmd(-2.2)) / 2:.4f}')


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    0.9352
    1.8462


Initializing Model Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We define two embedding layers for all the words in the vocabulary when
they are used as center words and context words, respectively. The word
vector dimension ``embed_size`` is set to 100.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    embed_size = 100
    net = nn.Sequential(nn.Embedding(num_embeddings=len(vocab),
                                     dims=embed_size),
                        nn.Embedding(num_embeddings=len(vocab),
                                     dims=embed_size))

Defining the Training Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~

The training loop is defined below. Because of the existence of padding,
the calculation of the loss function is slightly different compared to
the previous training functions.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def train(net, data_iter, num_batches, lr, num_epochs):
        optimizer = optim.Adam(learning_rate=lr)
        animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                                xlim=[1, num_epochs])
        def loss_fn(net, center, context_negative, label, mask):
            embeddings = net.children()["layers"]
            pred = skip_gram(center, context_negative, embeddings[0], embeddings[1])
            l = loss(inputs=pred.reshape(label.shape),
                     targets=label, weights=mask,
                     with_logits=True,
                     reduction='none').sum(axis=1) / mask.sum(axis=1)
            return mx.sum(l) / l.shape[0]
        # Sum of normalized losses, no. of normalized losses
        metric = d2l.Accumulator(2)
        for epoch in range(num_epochs):
            timer, num_batches = d2l.Timer(), num_batches
            for i, batch in enumerate(data_iter):
                center, context_negative, mask, label = mx.array(batch["centers"]), mx.array(batch["contexts_negatives"]), mx.array(batch["masks"]), mx.array(batch["labels"])
                loss_and_grad_fn = nn.value_and_grad(net, loss_fn)
                l, grads = loss_and_grad_fn(net, center, context_negative, label, mask)
                optimizer.update(net, grads)
                metric.add(l, l.size)
                if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                    animator.add(epoch + (i + 1) / num_batches,
                                 (metric[0] / metric[1],))
            data_iter.reset()
        print(f'loss {metric[0] / metric[1]:.3f}, '
              f'{metric[1] / timer.stop():.1f} tokens/sec')

Now we can train a skip-gram model using negative sampling.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    lr, num_epochs = 0.002, 5
    train(net, data_iter, num_batches, lr, num_epochs)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    loss 0.381, 941.5 tokens/sec



.. figure:: output_word2vec-pretraining_8b7dee_21_1.svg


.. _subsec_apply-word-embed:

Applying Word Embeddings
------------------------


After training the word2vec model, we can use the cosine similarity of
word vectors from the trained model to find words from the dictionary
that are most semantically similar to an input word.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def get_similar_tokens(query_token, k, embed):
        W = embed.weight
        x = W[vocab[query_token]]
        # Compute the cosine similarity. Add 1e-9 for numerical stability
        cos = (W @ x) / mx.sqrt(mx.sum(W * W, axis=1) *
                                          mx.sum(x * x) + 1e-9)
        topk = mx.argsort(-cos)[:k+1]
        for i in topk[1:]:
            print(f'cosine sim={float(cos[i]):.3f}: {vocab.to_tokens(i.item())}')
    
    get_similar_tokens('chip', 3, net.children()["layers"][0])


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    cosine sim=0.591: microprocessor
    cosine sim=0.540: intel
    cosine sim=0.521: motorola


Summary
-------

-  We can train a skip-gram model with negative sampling using embedding
   layers and the binary cross-entropy loss.
-  Applications of word embeddings include finding semantically similar
   words for a given word based on the cosine similarity of word
   vectors.

Exercises
---------

1. Using the trained model, find semantically similar words for other
   input words. Can you improve the results by tuning hyperparameters?
2. When a training corpus is huge, we often sample context words and
   noise words for the center words in the current minibatch *when
   updating model parameters*. In other words, the same center word may
   have different context words or noise words in different training
   epochs. What are the benefits of this method? Try to implement this
   training method.
