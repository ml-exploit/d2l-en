
.. _sec_kaggle_cifar10:

Image Classification (CIFAR-10) on Kaggle
=========================================


So far, we have been using high-level APIs of deep learning frameworks
to directly obtain image datasets in tensor format. However, custom
image datasets often come in the form of image files. In this section,
we will start from raw image files, and organize, read, then transform
them into tensor format step by step.

We experimented with the CIFAR-10 dataset in
:numref:`sec_image_augmentation`, which is an important dataset in
computer vision. In this section, we will apply the knowledge we learned
in previous sections to practice the Kaggle competition of CIFAR-10
image classification. The web address of the competition is
https://www.kaggle.com/c/cifar-10

:numref:`fig_kaggle_cifar10` shows the information on the
competition’s webpage. In order to submit the results, you need to
register a Kaggle account.

.. _fig_kaggle_cifar10:

.. figure:: ../img/kaggle-cifar10.png
   :width: 600px

   CIFAR-10 image classification competition webpage information. The
   competition dataset can be obtained by clicking the “Data” tab.



.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    import collections
    import glob
    import math
    import os
    import shutil
    import albumentations as A
    import mlx.core as mx
    import mlx.data as dx
    import mlx.optimizers as optim
    import numpy as np
    import pandas as pd
    from mlx import nn
    from d2l import mlx as d2l

Obtaining and Organizing the Dataset
------------------------------------

The competition dataset is divided into a training set and a test set,
which contain 50000 and 300000 images, respectively. In the test set,
10000 images will be used for evaluation, while the remaining 290000
images will not be evaluated: they are included just to make it hard to
cheat with *manually* labeled results of the test set. The images in
this dataset are all png color (RGB channels) image files, whose height
and width are both 32 pixels. The images cover a total of 10 categories,
namely airplanes, cars, birds, cats, deer, dogs, frogs, horses, boats,
and trucks. The upper-left corner of :numref:`fig_kaggle_cifar10`
shows some images of airplanes, cars, and birds in the dataset.

Downloading the Dataset
~~~~~~~~~~~~~~~~~~~~~~~

After logging in to Kaggle, we can click the “Data” tab on the CIFAR-10
image classification competition webpage shown in
:numref:`fig_kaggle_cifar10` and download the dataset by clicking the
“Download All” button. After unzipping the downloaded file in
``../data``, and unzipping ``train.7z`` and ``test.7z`` inside it, you
will find the entire dataset in the following paths:

-  ``../data/cifar-10/train/[1-50000].png``
-  ``../data/cifar-10/test/[1-300000].png``
-  ``../data/cifar-10/trainLabels.csv``
-  ``../data/cifar-10/sampleSubmission.csv``

where the ``train`` and ``test`` directories contain the training and
testing images, respectively, ``trainLabels.csv`` provides labels for
the training images, and ``sample_submission.csv`` is a sample
submission file.

To make it easier to get started, we provide a small-scale sample of the
dataset that contains the first 1000 training images and 5 random
testing images. To use the full dataset of the Kaggle competition, you
need to set the following ``demo`` variable to ``False``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    d2l.DATA_HUB['cifar10_tiny'] = (d2l.DATA_URL + 'kaggle_cifar10_tiny.zip',
                                    '2068874e4b9a9f0fb07ebe0ad2b29754449ccacd')
    
    # If you use the full dataset downloaded for the Kaggle competition, set
    # `demo` to False
    demo = True
    
    if demo:
        data_dir = d2l.download_extract('cifar10_tiny')
    else:
        data_dir = '../data/cifar-10/'

Organizing the Dataset
~~~~~~~~~~~~~~~~~~~~~~

We need to organize datasets to facilitate model training and testing.
Let’s first read the labels from the csv file. The following function
returns a dictionary that maps the non-extension part of the filename to
its label.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def read_csv_labels(fname):
        """Read `fname` to return a filename to label dictionary."""
        with open(fname, 'r') as f:
            # Skip the file header line (column name)
            lines = f.readlines()[1:]
        tokens = [l.rstrip().split(',') for l in lines]
        return dict(((name, label) for name, label in tokens))
    
    labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv'))
    print('# training examples:', len(labels))
    print('# classes:', len(set(labels.values())))


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    # training examples: 1000
    # classes: 10


Next, we define the ``reorg_train_valid`` function to split the
validation set out of the original training set. The argument
``valid_ratio`` in this function is the ratio of the number of examples
in the validation set to the number of examples in the original training
set. More concretely, let :math:`n` be the number of images of the class
with the least examples, and :math:`r` be the ratio. The validation set
will split out :math:`\max(\lfloor nr\rfloor,1)` images for each class.
Let’s use ``valid_ratio=0.1`` as an example. Since the original training
set has 50000 images, there will be 45000 images used for training in
the path ``train_valid_test/train``, while the other 5000 images will be
split out as validation set in the path ``train_valid_test/valid``.
After organizing the dataset, images of the same class will be placed
under the same folder.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def copyfile(filename, target_dir):
        """Copy a file into a target directory."""
        os.makedirs(target_dir, exist_ok=True)
        shutil.copy(filename, target_dir)
    
    #@save
    def reorg_train_valid(data_dir, labels, valid_ratio):
        """Split the validation set out of the original training set."""
        # The number of examples of the class that has the fewest examples in the
        # training dataset
        n = collections.Counter(labels.values()).most_common()[-1][1]
        # The number of examples per class for the validation set
        n_valid_per_label = max(1, math.floor(n * valid_ratio))
        label_count = {}
        for train_file in os.listdir(os.path.join(data_dir, 'train')):
            label = labels[train_file.split('.')[0]]
            fname = os.path.join(data_dir, 'train', train_file)
            copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                         'train_valid', label))
            if label not in label_count or label_count[label] < n_valid_per_label:
                copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                             'valid', label))
                label_count[label] = label_count.get(label, 0) + 1
            else:
                copyfile(fname, os.path.join(data_dir, 'train_valid_test',
                                             'train', label))
        return n_valid_per_label

The ``reorg_test`` function below organizes the testing set for data
loading during prediction.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def reorg_test(data_dir):
        """Organize the testing set for data loading during prediction."""
        for test_file in os.listdir(os.path.join(data_dir, 'test')):
            copyfile(os.path.join(data_dir, 'test', test_file),
                     os.path.join(data_dir, 'train_valid_test', 'test',
                                  'unknown'))

Finally, we use a function to invoke the ``read_csv_labels``,
``reorg_train_valid``, and ``reorg_test`` functions defined above.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def reorg_cifar10_data(data_dir, valid_ratio):
        labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv'))
        reorg_train_valid(data_dir, labels, valid_ratio)
        reorg_test(data_dir)

Here we only set the batch size to 32 for the small-scale sample of the
dataset. When training and testing the complete dataset of the Kaggle
competition, ``batch_size`` should be set to a larger integer, such as
128. We split out 10% of the training examples as the validation set for
tuning hyperparameters.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    batch_size = 32 if demo else 128
    valid_ratio = 0.1
    reorg_cifar10_data(data_dir, valid_ratio)

Image Augmentation
------------------

We use image augmentation to address overfitting. For example, images
can be flipped horizontally at random during training. We can also
perform standardization for the three RGB channels of color images.
Below lists some of these operations that you can tweak.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    transform_train = A.Compose([
        # Scale the image up to a square of 40 pixels in both height and width
        A.Resize(40, 40),
         # Randomly crop a square image of 40 pixels in both height and width to
        # produce a small square of 0.64 to 1 times the area of the original
        # image, and then scale it to a square of 32 pixels in both height and
        # width
        A.RandomResizedCrop((32, 32), scale=(0.64, 1.0),
                            ratio=(1.0, 1.0)),
        A.HorizontalFlip(p=0.5),
        # Standardize each channel of the image
        A.Normalize(mean=(0.4914, 0.4822, 0.4465), std=(0.2023, 0.1994, 0.2010)),
    ])

During testing, we only perform standardization on images so as to
remove randomness in the evaluation results.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    transform_test = A.Compose([
        A.Normalize(mean=(0.4914, 0.4822, 0.4465), std=(0.2023, 0.1994, 0.2010)),
    ])

Reading the Dataset
-------------------

Next, we read the organized dataset consisting of raw image files. Each
example includes an image and a label.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def files_and_classes(root, suffix=".png"):
        files = [str(f) for f in glob.glob(os.path.join(root, f"**/*{suffix}"), recursive=True)]
        files = [f for f in files if "BACKGROUND" not in f]
        class_to_idx = dict(
            map(reversed, enumerate(sorted(set(f.split("/")[-2] for f in files))))
        )
    
        idx_to_class = dict((v, k) for k, v in class_to_idx.items())
    
        data = [
            dict(image=f.encode("ascii"), label=class_to_idx[f.split("/")[-2]]) for f in files
        ]
    
        return data, idx_to_class
    
    #@save
    def create_dataset(root, transform=None, suffix=".png"):
        """Create a dataset from a folder"""
        data, idx_to_class = files_and_classes(root, suffix)
        dset = (
            dx.buffer_from_vector(data)
            .load_image("image")  # load the file pointed to by the 'image' key as an image
        )
        def process_sample(samples: dict) -> dict:
            image = samples["image"]
            label = samples["label"]
    
            image = transform(image=image)["image"]
            image = image.astype("float32") / 255.0
    
            label = label.astype("int32")
            return {"X": image, "y": label}
    
        dataset = dset.sample_transform(process_sample)
    
        return dataset, idx_to_class
    
    (train_ds, train_ds_classes), (train_valid_ds, train_valid_ds_classes) = [create_dataset(
        os.path.join(data_dir, 'train_valid_test', folder),
        transform=transform_train) for folder in ['train', 'train_valid']]
    
    (valid_ds, valid_ds_classes), (test_ds, test_ds_classes) = [create_dataset(
        os.path.join(data_dir, 'train_valid_test', folder),
        transform=transform_test) for folder in ['valid', 'test']]

During training, we need to specify all the image augmentation
operations defined above. When the validation set is used for model
evaluation during hyperparameter tuning, no randomness from image
augmentation should be introduced. Before final prediction, we train the
model on the combined training set and validation set to make full use
of all the labeled data.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    #@save
    def create_data_iter(dataset, batch_size, shuffle=True, drop_last=True):
        """Create an iterator for the CIFAR10 detection dataset"""
        len_dataset = len(dataset)
        if drop_last:
            num_batches = len_dataset // batch_size
        else:
            num_batches = math.ceil(len_dataset / batch_size)
    
        data_iter = (
            dataset
            .shuffle_if(shuffle)
            .to_stream()
            .batch(batch_size)
        )
        return data_iter, num_batches
    
    (train_iter, num_train_batches), (train_valid_iter, num_train_valid_batches) = [
        create_data_iter(
            dataset, batch_size, shuffle=True, drop_last=True
        )
        for dataset in (train_ds, train_valid_ds)
    ]
    valid_iter, num_valid_batches = create_data_iter(
        valid_ds, batch_size, shuffle=False, drop_last=True
    )
    test_iter, num_test_batches = create_data_iter(
        test_ds, batch_size, shuffle=False, drop_last=False
    )

Defining the Model
------------------

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def get_net():
        num_classes = 10
        net = d2l.resnet18(num_classes, 3)
        return net
    
    loss_fn = nn.losses.cross_entropy

Defining the Training Function
------------------------------

We will select models and tune hyperparameters according to the model’s
performance on the validation set. In the following, we define the model
training function ``train``.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    def train(net, train_iter, num_batches, valid_iter, loss_fn, num_epochs, lr, wd, lr_period,lr_decay):
        scheduler = optim.step_decay(lr, lr_decay, lr_period)
        trainer = optim.SGD(learning_rate=scheduler, momentum=0.9, weight_decay=wd)
        timer = d2l.Timer()
        legend = ['train loss', 'train acc']
        if valid_iter is not None:
            legend.append('valid acc')
        animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],
                                legend=legend)
        def train_step(net, X, y):
            y_hat = net(X)
            los = loss_fn(y_hat, y, reduction='sum')
            acc = mx.sum(mx.argmax(y_hat, axis=-1) == y)
            return los, acc
        for epoch in range(num_epochs):
            net.train()
            metric = d2l.Accumulator(3)
            for i, samples in enumerate(train_iter):
                features, labels = mx.array(samples["X"]), mx.array(samples["y"])
                timer.start()
                l, acc = d2l.train_batch_ch13(net, features, labels,
                                              train_step, trainer)
                metric.add(l, acc, labels.shape[0])
                timer.stop()
                if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                    animator.add(epoch + (i + 1) / num_batches,
                                 (metric[0] / metric[2], metric[1] / metric[2],
                                  None))
            train_iter.reset()
            if valid_iter is not None:
                valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter)
                animator.add(epoch + 1, (None, None, valid_acc))
        measures = (f'train loss {metric[0] / metric[2]:.3f}, '
                    f'train acc {metric[1] / metric[2]:.3f}')
        if valid_iter is not None:
            measures += f', valid acc {valid_acc:.3f}'
        print(measures + f'\n{metric[2] * num_epochs / timer.sum():.1f}'
              f' examples/sec')

Training and Validating the Model
---------------------------------

Now, we can train and validate the model. All the following
hyperparameters can be tuned. For example, we can increase the number of
epochs. When ``lr_period`` and ``lr_decay`` are set to 4 and 0.9,
respectively, the learning rate of the optimization algorithm will be
multiplied by 0.9 after every 4 epochs. Just for ease of demonstration,
we only train 20 epochs here.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    num_epochs, lr, wd = 20, 2e-4, 5e-4
    lr_period, lr_decay, net = 10, 0.95, get_net()
    train(net, train_iter, num_train_batches, valid_iter, loss_fn, num_epochs, lr, wd, lr_period,
          lr_decay)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    train loss 0.514, train acc 0.837, valid acc 0.412
    2194.1 examples/sec



.. figure:: output_kaggle-cifar10_c0cabc_27_1.svg


Classifying the Testing Set and Submitting Results on Kaggle
------------------------------------------------------------

After obtaining a promising model with hyperparameters, we use all the
labeled data (including the validation set) to retrain the model and
classify the testing set.

.. raw:: latex

   \diilbookstyleinputcell

.. code:: python

    net, preds = get_net(), []
    train(net, train_valid_iter, num_train_valid_batches,None, loss_fn, num_epochs, lr, wd,  lr_period,
          lr_decay)
    
    test_iter.reset()
    for samples in test_iter:
        X = mx.array(samples["X"])
        y_hat = net(X)
        preds.extend(np.array(y_hat.argmax(axis=1)).astype(np.int32))
    sorted_ids = list(range(1, len(test_ds) + 1))
    sorted_ids.sort(key=lambda x: str(x))
    
    df = pd.DataFrame({'id': sorted_ids, 'label': preds})
    df['label'] = df['label'].apply(lambda x: train_valid_ds_classes[x])
    df.to_csv('submission.csv', index=False)


.. raw:: latex

   \diilbookstyleoutputcell

.. parsed-literal::
    :class: output

    train loss 0.436, train acc 0.862
    1216.3 examples/sec



.. figure:: output_kaggle-cifar10_c0cabc_29_1.svg


The above code will generate a ``submission.csv`` file, whose format
meets the requirement of the Kaggle competition. The method for
submitting results to Kaggle is similar to that in
:numref:`sec_kaggle_house`.

Summary
-------

-  We can read datasets containing raw image files after organizing them
   into the required format.

Exercises
---------

1. Use the complete CIFAR-10 dataset for this Kaggle competition. Set
   hyperparameters as ``batch_size = 128``, ``num_epochs = 100``,
   ``lr = 0.1``, ``lr_period = 50``, and ``lr_decay = 0.1``. See what
   accuracy and ranking you can achieve in this competition. Can you
   further improve them?
2. What accuracy can you get when not using image augmentation?
